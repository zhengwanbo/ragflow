import json
import re
import oracledb as oracle
from peewee import *
from peewee import Database
from peewee import ImproperlyConfigured
from peewee import SQL
from peewee import fn
from peewee import EnclosedNodeList
from peewee import Entity
from peewee import Node
from peewee import NodeList
from peewee import TextField

#from peewee import compiler
import logging
from playhouse.pool import PooledDatabase
from playhouse.migrate import SchemaMigrator

logging.basicConfig(
    level=logging.DEBUG,
    format='%(levelname)s - %(filename)s:%(lineno)d - %(message)s'
)
logger = logging.getLogger('oracle_ext')
#logger.setLevel(logging.DEBUG)

class ExceptionWrapper(object):
    __slots__ = ('exceptions',)
    def __init__(self, exceptions):
        self.exceptions = exceptions
    def __enter__(self): pass
    def __exit__(self, exc_type, exc_value, traceback):
        if exc_type is None:
            return

EXCEPTIONS = {
    'ConstraintError': IntegrityError,
    'DatabaseError': DatabaseError,
    'DataError': DataError,
    'IntegrityError': IntegrityError,
    'InterfaceError': InterfaceError,
    'InternalError': InternalError,
    'NotSupportedError': NotSupportedError,
    'OperationalError': OperationalError,
    'ProgrammingError': ProgrammingError,
    'TransactionRollbackError': OperationalError,
    'UndefinedFunction': ProgrammingError,
    'UniqueViolation': IntegrityError}

__exception_wrapper__ = ExceptionWrapper(EXCEPTIONS)

class OracleDatabase(Database):
    field_types = {
        'AUTO': 'NUMBER GENERATED BY DEFAULT AS IDENTITY',
        'BIGAUTO': 'NUMBER GENERATED BY DEFAULT AS IDENTITY',
        'BOOL': 'NUMBER(1)',
        'DECIMAL': 'NUMBER',
        'DOUBLE': 'BINARY_DOUBLE',
        'FLOAT': 'BINARY_FLOAT',
        'INT': 'NUMBER(11)',
        'BIGINT': 'NUMBER(19)',
        'SMALLINT': 'NUMBER(4)',
        'VARCHAR': 'VARCHAR2',
        'TEXT': 'CLOB',
        'JSON': 'JSON',
        'DATETIME': 'TIMESTAMP',
        'DATE': 'DATE',
        'TIME': 'TIMESTAMP',
        'BLOB': 'BLOB',
        'UUID': 'VARCHAR2(32)',
        'UUIDB': 'RAW(16)'
    }
    operations = {
        'LIKE': 'LIKE',
        'ILIKE': 'LIKE',
        'REGEXP': 'REGEXP_LIKE',
        'IREGEXP': 'REGEXP_LIKE',
        'BETWEEN': 'BETWEEN',
        'MATCH': 'LIKE',
        'XOR': 'XOR'
    }
    param = ':%d'

    def _connect(self):
        if oracle is None:
            raise ImproperlyConfigured('oracledb is required.')
        #logger.debug(self.connect_params)
        user = self.connect_params.get('user')
        password = self.connect_params.get('password')
        db = self.connect_params.get('db','freepdb1')
        host = self.connect_params.get('host')
        port = self.connect_params.get('port')
        encoding = self.connect_params.get('encoding')
        nencoding = self.connect_params.get('nencoding')

        # 构建 DSN
        if user and password and host and port and db:
            dsn = f'{user}/{password}@{host}:{port}/{db}'
            #logger.info(f"生成的 DSN 字符串: {dsn}")
        else:
            logger.error("缺少必要的连接参数，无法生成 DSN 字符串。")

        conn = oracle.connect(dsn)
        #conn = oracle.create_pool(
        #    user= user,
        #    password= password,
        #    dsn="{}:{}/{}".format(host, port, db),
        #    min=1,
        #    max=50,
        #    increment=1,
        #)

        return conn

    def _placeholder(self, idx):
        return ':%d' % idx

    def extract_date(self, date_part, date_field):
        # Oracle的日期提取函数
        return fn.EXTRACT(date_part, date_field)

    def truncate_date(self, date_field, date_part):
        # Oracle的日期截断函数
        return fn.TRUNC(date_field, date_part)

    def from_timestamp(self, date_field):
        return date_field.cast('TIMESTAMP')

    def random(self):
        return fn.DBMS_RANDOM.VALUE()

    def quote_char(self):
        # Oracle 使用单引号作为标识符引用
        return "'"

    def compiler(self):
        return OracleCompiler(self)

    def get_binary_type(self):
        return oracle.BLOB

    def begin(self):
        if self.is_closed():
            self.connect()
        with __exception_wrapper__:
            self.cursor().execute('COMMIT')

    def rollback(self):
        with __exception_wrapper__:
            self.cursor().execute('ROLLBACK')

    def commit(self):
        with __exception_wrapper__:
            self.cursor().execute('COMMIT')

    def execute_sql(self, sql, params=None, commit=None):
        if commit is not None:
            __deprecated__('"commit" has been deprecated and is a no-op.')

        if isinstance(sql, str) and params:
            # 替换 :%d 为实际的参数序号
            param_count = 1
            while ':%d' in sql:
                sql = sql.replace(':%d', ':%d' % param_count, 1)
                param_count += 1

        # 去除 SQL 中的 AS 字符串
        sql = sql.replace(" AS ", " ")

        # 处理 LIMIT 替换为 FETCH FIRST 和 OFFSET
        if "LIMIT" in sql.upper():
            limit_index = sql.upper().find("LIMIT")
            limit_value = sql[limit_index + len("LIMIT"):].strip()
            limit_placeholder = None
            offset_placeholder = None
            if "OFFSET" in limit_value.upper():
                offset_index = limit_value.upper().find("OFFSET")
                offset_part = limit_value[offset_index + len("OFFSET"):].strip()
                limit_part = limit_value[:offset_index].strip()
                # 提取 LIMIT 和 OFFSET 后面的占位符序号
                limit_match = re.search(r':(\d+)', limit_part)
                offset_match = re.search(r':(\d+)', offset_part)
                if limit_match:
                    limit_placeholder = int(limit_match.group(1))
                if offset_match:
                    offset_placeholder = int(offset_match.group(1))

                sql = sql[:limit_index] + f"OFFSET {limit_part} ROWS FETCH FIRST {offset_part} ROWS ONLY "
            else:
                sql = sql[:limit_index] + f"FETCH FIRST {limit_value} ROWS ONLY"

            # 根据占位符序号调整参数顺序
            if limit_placeholder and offset_placeholder and params:
                limit_index_in_params = limit_placeholder - 1
                offset_index_in_params = offset_placeholder - 1
                params[limit_index_in_params], params[offset_index_in_params] = params[offset_index_in_params], params[limit_index_in_params]

        logger.debug((sql, params))
        cursor = self.cursor()

        result = None
        try:
            cursor.execute(sql, params or ())
            # 对于 INSERT、UPDATE、DELETE 语句，需要提交事务
            if sql.strip().upper().startswith(('INSERT', 'UPDATE', 'DELETE')):
                cursor.connection.commit()
        except oracle.Error as e:
            # 打印 SQL 信息和参数
            logger.debug(f"执行的 SQL 语句: {sql}")
            logger.debug(f"使用的参数: {params}")
            error, = e.args
            logger.error(f"执行 SQL 时出现错误: {error.message}")

        return cursor


    def execute(self, query, commit=None, **context_options):
        if commit is not None:
            __deprecated__('"commit" has been deprecated and is a no-op.')
        ctx = self.get_sql_context(**context_options)
        sql, params = ctx.sql(query).query()
        return self.execute_sql(sql, params)


    def insert(self, insert=None, columns=None, **kwargs):
        if kwargs:
            insert = {} if insert is None else insert
            src = self if self._columns else self.c
            for key, value in kwargs.items():
                insert[getattr(src, key)] = value
        return Insert(self, insert=insert, columns=columns)

    def delete(self):
        return Delete(self)

    def update(self, update=None, **kwargs):
        if kwargs:
            update = {} if update is None else update
            for key, value in kwargs.items():
                src = self if self._columns else self.c
                update[getattr(src, key)] = value
        return Update(self, update=update)


    def _create_context(self, **kwargs):
        context = super()._create_context(**kwargs)
        # 设置 Oracle 特定的参数绑定格式
        context.param = ':%d'
        context.quote = "'"
        return context

    def _iterate(self, cache=True):
        # 检查游标是否处于可获取结果的状态
        row = self.cursor.fetchone()
        if row is None:
            self.populated = True
            self.cursor.close()
            raise StopIteration
        elif not self.initialized:
            self.initialize()  # Lazy initialization.
            self.initialized = True
        self.count += 1
        result = self.process_row(row)
        if cache:
            self.row_cache.append(result)

        return result

    def parse_node(self, node, **kwargs):
        # 重写解析方法以处理 Oracle 特定的语法
        if isinstance(node, Entity):
            # 对于表名和列名使用单引号
            return node.name if node.name == '*' else "'%s'" % node.name
        return super().parse_node(node, **kwargs)

    def field_definition(self, field):
        # 重写字段定义方法以适应 Oracle 语法
        column_type = self.get_column_type(field)
        ddl = field.name + ' ' + column_type
        if not field.null:
            ddl += ' NOT NULL'
        if field.primary_key:
            ddl += ' PRIMARY KEY'
        if field.default is not None:
            ddl += ' DEFAULT %s' % self.get_default_value(field)
        return ddl

    def get_column_type(self, field):
        # 获取 Oracle 特定的列类型
        field_type = field.get_db_field()
        if field_type in self.database.field_types:
            return self.database.field_types[field_type]
        return field_type

    def get_default_value(self, field):
        # 处理默认值
        if field.default is None:
            return 'NULL'
        if callable(field.default):
            default = field.default()
        else:
            default = field.default
        if isinstance(default, str):
            return "'%s'" % default
        return str(default) 


class FetchManyCursor(object):
    __slots__ = ('cursor', 'array_size', 'exhausted', 'iterable')

    def __init__(self, cursor, array_size=None):
        self.cursor = cursor
        self.array_size = array_size or cursor.itersize
        self.exhausted = False
        self.iterable = self.row_gen()

    def __del__(self):
        if self.cursor and not self.cursor.closed:
            try:
                self.cursor.close()
            except Exception:
                pass

    @property
    def description(self):
        return self.cursor.description

    def close(self):
        self.cursor.close()

    def row_gen(self):
        try:
            while True:
                rows = self.cursor.fetchmany(self.array_size)
                if not rows:
                    return
                for row in rows:
                    yield row
        finally:
            self.close()

class JSONField(TextField):
    field_type = 'JSON'

    def __init__(self, json_dumps=None, json_loads=None, **kwargs):
        self._json_dumps = json_dumps or json.dumps
        self._json_loads = json_loads or json.loads
        super(JSONField, self).__init__(**kwargs)

    def db_value(self, value):
        if value is not None:
            if not isinstance(value, Node):
                return self._json_dumps(value)
            return value

    def python_value(self, value):
        logger.debug(value)
        if value is not None:
            try:
                #return self._json_loads(value)
                return fn.JSON_EXISTS(self, SQL("'$[*]?(@ == %s)'" % value))
            except (TypeError, ValueError):
                return value

    def contains(self, value):
        # Oracle JSON查询
        return fn.JSON_EXISTS(self, SQL("'$[*]?(@ == %s)'" % value))


class PooledOracleDatabase(PooledDatabase, OracleDatabase):
    def _is_closed(self, conn):
        try:
            return not bool(conn.ping())
        except:
            return True

    def _can_reuse(self, conn):
        try:
            conn.ping()
            return True
        except:
            return False 


class OracleMigrator(SchemaMigrator):
    def _alter_table(self, table, operation):
        statement = 'ALTER TABLE %s %s' % (table, operation)
        return self.execute(statement)

    def add_column(self, table, column_name, field):
        # Oracle 不支持在 ADD COLUMN 时使用 AS 关键字
        operations = []
        field_clause = field.ddl(column_name)
        operations.append(('ADD %s' % field_clause, []))
        return self._alter_table(table, *operations[0])

    def drop_column(self, table, column_name, cascade=True):
        # Oracle 使用 DROP COLUMN 而不是 DROP
        operation = 'DROP COLUMN %s' % column_name
        if cascade:
            operation += ' CASCADE CONSTRAINTS'
        return self._alter_table(table, operation)

    def rename_column(self, table, old_name, new_name):
        # Oracle 使用 RENAME COLUMN TO 语法
        operation = 'RENAME COLUMN %s TO %s' % (old_name, new_name)
        return self._alter_table(table, operation)

    def drop_not_null(self, table, column_name):
        # Oracle 使用 MODIFY 来修改列属性
        operation = 'MODIFY %s NULL' % column_name
        return self._alter_table(table, operation)

        operation = 'MODIFY %s NOT NULL' % column_name
        return self._alter_table(table, operation)

        operation = 'MODIFY %s %s' % (column, field.get_modifiers()[0])
        return self._alter_table(table, operation)

    def add_index(self, table, columns, unique=False, using=None):
        # Oracle 不支持 USING 子句，但支持创建唯一索引
        compiler = self.database.compiler()
        index_name = self.generate_index_name(table, columns)
        nodes = [SQL('CREATE')]
        if unique:
            nodes.append(SQL('UNIQUE'))
        nodes.extend([
            SQL('INDEX'),
            Entity(index_name),
            SQL('ON'),
            Entity(table),
            EnclosedNodeList([Entity(column) for column in columns])
        ])
        return self.execute(compiler.parse(NodeList(nodes)))

    def drop_index(self, table, index_name):
        return self.execute('DROP INDEX %s' % index_name)

    def add_foreign_key_constraint(self, table, foreign_key_field):
        # Oracle 使用标准的 ADD CONSTRAINT 语法
        constraint = foreign_key_field.foreign_key_constraint()
        name = self.generate_constraint_name(table, foreign_key_field)
        operation = 'ADD CONSTRAINT %s %s' % (name, constraint)
        return self._alter_table(table, operation)

    def drop_foreign_key_constraint(self, table, fk_name):
        # Oracle 使用 DROP CONSTRAINT 语法
        operation = 'DROP CONSTRAINT %s' % fk_name
        return self._alter_table(table, operation)

    def add_sequence(self, table, column):
        # Oracle 特有的序列创建
        seq_name = '%s_%s_seq' % (table, column)
        operations = [
            'CREATE SEQUENCE %s START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE' % seq_name,
            'CREATE TRIGGER %s_%s_trg BEFORE INSERT ON %s FOR EACH ROW BEGIN SELECT %s.nextval INTO :new.%s FROM dual; END;' %
            (table, column, table, seq_name, column)
        ]
        for operation in operations:
            self.execute(operation)

    def drop_sequence(self, table, column):
        # Oracle 特有的序列删除
        seq_name = '%s_%s_seq' % (table, column)
        trigger_name = '%s_%s_trg' % (table, column)
        operations = [
            'DROP TRIGGER %s' % trigger_name,
            'DROP SEQUENCE %s' % seq_name
        ]
        for operation in operations:
            try:
                self.execute(operation)
            except:
                pass
